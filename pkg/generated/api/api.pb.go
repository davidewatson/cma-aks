// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

package cmaaks

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateClusterMsg struct {
	// Name of the cluster to be provisioned
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The provider specification
	Provider             *CreateClusterProviderSpec `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CreateClusterMsg) Reset()         { *m = CreateClusterMsg{} }
func (m *CreateClusterMsg) String() string { return proto.CompactTextString(m) }
func (*CreateClusterMsg) ProtoMessage()    {}
func (*CreateClusterMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{0}
}
func (m *CreateClusterMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterMsg.Unmarshal(m, b)
}
func (m *CreateClusterMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterMsg.Marshal(b, m, deterministic)
}
func (dst *CreateClusterMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterMsg.Merge(dst, src)
}
func (m *CreateClusterMsg) XXX_Size() int {
	return xxx_messageInfo_CreateClusterMsg.Size(m)
}
func (m *CreateClusterMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterMsg proto.InternalMessageInfo

func (m *CreateClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateClusterMsg) GetProvider() *CreateClusterProviderSpec {
	if m != nil {
		return m.Provider
	}
	return nil
}

type CreateClusterReply struct {
	// Whether or not the cluster was provisioned by this request
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// The details of the cluster request response
	Cluster              *ClusterItem `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CreateClusterReply) Reset()         { *m = CreateClusterReply{} }
func (m *CreateClusterReply) String() string { return proto.CompactTextString(m) }
func (*CreateClusterReply) ProtoMessage()    {}
func (*CreateClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{1}
}
func (m *CreateClusterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterReply.Unmarshal(m, b)
}
func (m *CreateClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterReply.Marshal(b, m, deterministic)
}
func (dst *CreateClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterReply.Merge(dst, src)
}
func (m *CreateClusterReply) XXX_Size() int {
	return xxx_messageInfo_CreateClusterReply.Size(m)
}
func (m *CreateClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterReply proto.InternalMessageInfo

func (m *CreateClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *CreateClusterReply) GetCluster() *ClusterItem {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type GetClusterMsg struct {
	// Name of the cluster to be looked up
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Credentials to query for the cluster
	Credentials          *AzureCredentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetClusterMsg) Reset()         { *m = GetClusterMsg{} }
func (m *GetClusterMsg) String() string { return proto.CompactTextString(m) }
func (*GetClusterMsg) ProtoMessage()    {}
func (*GetClusterMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{2}
}
func (m *GetClusterMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetClusterMsg.Unmarshal(m, b)
}
func (m *GetClusterMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetClusterMsg.Marshal(b, m, deterministic)
}
func (dst *GetClusterMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterMsg.Merge(dst, src)
}
func (m *GetClusterMsg) XXX_Size() int {
	return xxx_messageInfo_GetClusterMsg.Size(m)
}
func (m *GetClusterMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterMsg proto.InternalMessageInfo

func (m *GetClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetClusterMsg) GetCredentials() *AzureCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type GetClusterReply struct {
	// Is the cluster in the system
	Ok                   bool               `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Cluster              *ClusterDetailItem `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetClusterReply) Reset()         { *m = GetClusterReply{} }
func (m *GetClusterReply) String() string { return proto.CompactTextString(m) }
func (*GetClusterReply) ProtoMessage()    {}
func (*GetClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{3}
}
func (m *GetClusterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetClusterReply.Unmarshal(m, b)
}
func (m *GetClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetClusterReply.Marshal(b, m, deterministic)
}
func (dst *GetClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterReply.Merge(dst, src)
}
func (m *GetClusterReply) XXX_Size() int {
	return xxx_messageInfo_GetClusterReply.Size(m)
}
func (m *GetClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterReply proto.InternalMessageInfo

func (m *GetClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetClusterReply) GetCluster() *ClusterDetailItem {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type DeleteClusterMsg struct {
	// What is the cluster's name to destroy
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Credentials to delete the cluster
	Credentials          *AzureCredentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DeleteClusterMsg) Reset()         { *m = DeleteClusterMsg{} }
func (m *DeleteClusterMsg) String() string { return proto.CompactTextString(m) }
func (*DeleteClusterMsg) ProtoMessage()    {}
func (*DeleteClusterMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{4}
}
func (m *DeleteClusterMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteClusterMsg.Unmarshal(m, b)
}
func (m *DeleteClusterMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteClusterMsg.Marshal(b, m, deterministic)
}
func (dst *DeleteClusterMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteClusterMsg.Merge(dst, src)
}
func (m *DeleteClusterMsg) XXX_Size() int {
	return xxx_messageInfo_DeleteClusterMsg.Size(m)
}
func (m *DeleteClusterMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteClusterMsg.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteClusterMsg proto.InternalMessageInfo

func (m *DeleteClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteClusterMsg) GetCredentials() *AzureCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type DeleteClusterReply struct {
	// Could the cluster be destroyed
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// Status of the request
	Status               string   `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteClusterReply) Reset()         { *m = DeleteClusterReply{} }
func (m *DeleteClusterReply) String() string { return proto.CompactTextString(m) }
func (*DeleteClusterReply) ProtoMessage()    {}
func (*DeleteClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{5}
}
func (m *DeleteClusterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteClusterReply.Unmarshal(m, b)
}
func (m *DeleteClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteClusterReply.Marshal(b, m, deterministic)
}
func (dst *DeleteClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteClusterReply.Merge(dst, src)
}
func (m *DeleteClusterReply) XXX_Size() int {
	return xxx_messageInfo_DeleteClusterReply.Size(m)
}
func (m *DeleteClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteClusterReply proto.InternalMessageInfo

func (m *DeleteClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *DeleteClusterReply) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type GetClusterListMsg struct {
	// Credentials to search subscription for clusters
	Credentials          *AzureCredentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetClusterListMsg) Reset()         { *m = GetClusterListMsg{} }
func (m *GetClusterListMsg) String() string { return proto.CompactTextString(m) }
func (*GetClusterListMsg) ProtoMessage()    {}
func (*GetClusterListMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{6}
}
func (m *GetClusterListMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetClusterListMsg.Unmarshal(m, b)
}
func (m *GetClusterListMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetClusterListMsg.Marshal(b, m, deterministic)
}
func (dst *GetClusterListMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterListMsg.Merge(dst, src)
}
func (m *GetClusterListMsg) XXX_Size() int {
	return xxx_messageInfo_GetClusterListMsg.Size(m)
}
func (m *GetClusterListMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterListMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterListMsg proto.InternalMessageInfo

func (m *GetClusterListMsg) GetCredentials() *AzureCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type GetClusterListReply struct {
	// Is the cluster in the system
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// List of clusters
	Clusters             []*ClusterItem `protobuf:"bytes,2,rep,name=clusters,proto3" json:"clusters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetClusterListReply) Reset()         { *m = GetClusterListReply{} }
func (m *GetClusterListReply) String() string { return proto.CompactTextString(m) }
func (*GetClusterListReply) ProtoMessage()    {}
func (*GetClusterListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{7}
}
func (m *GetClusterListReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetClusterListReply.Unmarshal(m, b)
}
func (m *GetClusterListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetClusterListReply.Marshal(b, m, deterministic)
}
func (dst *GetClusterListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterListReply.Merge(dst, src)
}
func (m *GetClusterListReply) XXX_Size() int {
	return xxx_messageInfo_GetClusterListReply.Size(m)
}
func (m *GetClusterListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterListReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterListReply proto.InternalMessageInfo

func (m *GetClusterListReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetClusterListReply) GetClusters() []*ClusterItem {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type ClusterItem struct {
	// ID of the cluster
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name of the cluster
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// What is the status of the cluster
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterItem) Reset()         { *m = ClusterItem{} }
func (m *ClusterItem) String() string { return proto.CompactTextString(m) }
func (*ClusterItem) ProtoMessage()    {}
func (*ClusterItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{8}
}
func (m *ClusterItem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterItem.Unmarshal(m, b)
}
func (m *ClusterItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterItem.Marshal(b, m, deterministic)
}
func (dst *ClusterItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterItem.Merge(dst, src)
}
func (m *ClusterItem) XXX_Size() int {
	return xxx_messageInfo_ClusterItem.Size(m)
}
func (m *ClusterItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterItem.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterItem proto.InternalMessageInfo

func (m *ClusterItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type ClusterDetailItem struct {
	// ID of the cluster
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name of the cluster
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// What is the status of the cluster
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// What is the kubeconfig to connect to the cluster
	Kubeconfig           string   `protobuf:"bytes,4,opt,name=kubeconfig,proto3" json:"kubeconfig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterDetailItem) Reset()         { *m = ClusterDetailItem{} }
func (m *ClusterDetailItem) String() string { return proto.CompactTextString(m) }
func (*ClusterDetailItem) ProtoMessage()    {}
func (*ClusterDetailItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{9}
}
func (m *ClusterDetailItem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterDetailItem.Unmarshal(m, b)
}
func (m *ClusterDetailItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterDetailItem.Marshal(b, m, deterministic)
}
func (dst *ClusterDetailItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterDetailItem.Merge(dst, src)
}
func (m *ClusterDetailItem) XXX_Size() int {
	return xxx_messageInfo_ClusterDetailItem.Size(m)
}
func (m *ClusterDetailItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterDetailItem.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterDetailItem proto.InternalMessageInfo

func (m *ClusterDetailItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterDetailItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterDetailItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ClusterDetailItem) GetKubeconfig() string {
	if m != nil {
		return m.Kubeconfig
	}
	return ""
}

type CreateClusterProviderSpec struct {
	// What is the provider - like aks
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The version of Kubernetes
	K8SVersion string `protobuf:"bytes,2,opt,name=k8s_version,json=k8sVersion,proto3" json:"k8s_version,omitempty"`
	// The AKS specification
	Azure *CreateClusterAKSSpec `protobuf:"bytes,3,opt,name=azure,proto3" json:"azure,omitempty"`
	// Whether or not the cluster is HA
	HighAvailability bool `protobuf:"varint,4,opt,name=high_availability,json=highAvailability,proto3" json:"high_availability,omitempty"`
	// The fabric to be used
	NetworkFabric        string   `protobuf:"bytes,5,opt,name=network_fabric,json=networkFabric,proto3" json:"network_fabric,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateClusterProviderSpec) Reset()         { *m = CreateClusterProviderSpec{} }
func (m *CreateClusterProviderSpec) String() string { return proto.CompactTextString(m) }
func (*CreateClusterProviderSpec) ProtoMessage()    {}
func (*CreateClusterProviderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{10}
}
func (m *CreateClusterProviderSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterProviderSpec.Unmarshal(m, b)
}
func (m *CreateClusterProviderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterProviderSpec.Marshal(b, m, deterministic)
}
func (dst *CreateClusterProviderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterProviderSpec.Merge(dst, src)
}
func (m *CreateClusterProviderSpec) XXX_Size() int {
	return xxx_messageInfo_CreateClusterProviderSpec.Size(m)
}
func (m *CreateClusterProviderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterProviderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterProviderSpec proto.InternalMessageInfo

func (m *CreateClusterProviderSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateClusterProviderSpec) GetK8SVersion() string {
	if m != nil {
		return m.K8SVersion
	}
	return ""
}

func (m *CreateClusterProviderSpec) GetAzure() *CreateClusterAKSSpec {
	if m != nil {
		return m.Azure
	}
	return nil
}

func (m *CreateClusterProviderSpec) GetHighAvailability() bool {
	if m != nil {
		return m.HighAvailability
	}
	return false
}

func (m *CreateClusterProviderSpec) GetNetworkFabric() string {
	if m != nil {
		return m.NetworkFabric
	}
	return ""
}

// The credentials to use for creating the cluster
type AzureCredentials struct {
	// The AppId for API Access
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// The Tenant for API access
	Tenant string `protobuf:"bytes,2,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// The Password for API access
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// The Subscription for API access
	SubscriptionId       string   `protobuf:"bytes,4,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureCredentials) Reset()         { *m = AzureCredentials{} }
func (m *AzureCredentials) String() string { return proto.CompactTextString(m) }
func (*AzureCredentials) ProtoMessage()    {}
func (*AzureCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{11}
}
func (m *AzureCredentials) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AzureCredentials.Unmarshal(m, b)
}
func (m *AzureCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AzureCredentials.Marshal(b, m, deterministic)
}
func (dst *AzureCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureCredentials.Merge(dst, src)
}
func (m *AzureCredentials) XXX_Size() int {
	return xxx_messageInfo_AzureCredentials.Size(m)
}
func (m *AzureCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_AzureCredentials proto.InternalMessageInfo

func (m *AzureCredentials) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *AzureCredentials) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *AzureCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AzureCredentials) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

// the account used by the cluster to create azure resources (ex: load balancer)
type AzureClusterServiceAccount struct {
	// The ClientId (aka: AppID)
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// The ClientSecret (aka: password)
	ClientSecret         string   `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureClusterServiceAccount) Reset()         { *m = AzureClusterServiceAccount{} }
func (m *AzureClusterServiceAccount) String() string { return proto.CompactTextString(m) }
func (*AzureClusterServiceAccount) ProtoMessage()    {}
func (*AzureClusterServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{12}
}
func (m *AzureClusterServiceAccount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AzureClusterServiceAccount.Unmarshal(m, b)
}
func (m *AzureClusterServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AzureClusterServiceAccount.Marshal(b, m, deterministic)
}
func (dst *AzureClusterServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureClusterServiceAccount.Merge(dst, src)
}
func (m *AzureClusterServiceAccount) XXX_Size() int {
	return xxx_messageInfo_AzureClusterServiceAccount.Size(m)
}
func (m *AzureClusterServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureClusterServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_AzureClusterServiceAccount proto.InternalMessageInfo

func (m *AzureClusterServiceAccount) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *AzureClusterServiceAccount) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

type CreateClusterAKSSpec struct {
	// The Azure Data Center
	Location string `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Credentials to build the cluster
	Credentials *AzureCredentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	// Cluster service account used to talk to azure (ex: creating load balancer)
	ClusterAccount *AzureClusterServiceAccount `protobuf:"bytes,3,opt,name=clusterAccount,proto3" json:"clusterAccount,omitempty"`
	// Instance groups
	InstanceGroups []*CreateClusterAKSSpec_AKSInstanceGroup `protobuf:"bytes,4,rep,name=instance_groups,json=instanceGroups,proto3" json:"instance_groups,omitempty"`
	// Tags
	Tags                 []*CreateClusterAKSSpec_Tags `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CreateClusterAKSSpec) Reset()         { *m = CreateClusterAKSSpec{} }
func (m *CreateClusterAKSSpec) String() string { return proto.CompactTextString(m) }
func (*CreateClusterAKSSpec) ProtoMessage()    {}
func (*CreateClusterAKSSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{13}
}
func (m *CreateClusterAKSSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterAKSSpec.Unmarshal(m, b)
}
func (m *CreateClusterAKSSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterAKSSpec.Marshal(b, m, deterministic)
}
func (dst *CreateClusterAKSSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterAKSSpec.Merge(dst, src)
}
func (m *CreateClusterAKSSpec) XXX_Size() int {
	return xxx_messageInfo_CreateClusterAKSSpec.Size(m)
}
func (m *CreateClusterAKSSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterAKSSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterAKSSpec proto.InternalMessageInfo

func (m *CreateClusterAKSSpec) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *CreateClusterAKSSpec) GetCredentials() *AzureCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *CreateClusterAKSSpec) GetClusterAccount() *AzureClusterServiceAccount {
	if m != nil {
		return m.ClusterAccount
	}
	return nil
}

func (m *CreateClusterAKSSpec) GetInstanceGroups() []*CreateClusterAKSSpec_AKSInstanceGroup {
	if m != nil {
		return m.InstanceGroups
	}
	return nil
}

func (m *CreateClusterAKSSpec) GetTags() []*CreateClusterAKSSpec_Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Instance groups define a type and number of instances
type CreateClusterAKSSpec_AKSInstanceGroup struct {
	// The name of the group
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Instance type (Standard_D2_v2, etc.)
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Minimum number of instances (defaults to zero)
	MinQuantity int32 `protobuf:"varint,3,opt,name=min_quantity,json=minQuantity,proto3" json:"min_quantity,omitempty"`
	// Maximum number of instances (defaults to zero)
	MaxQuantity          int32    `protobuf:"varint,4,opt,name=max_quantity,json=maxQuantity,proto3" json:"max_quantity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateClusterAKSSpec_AKSInstanceGroup) Reset()         { *m = CreateClusterAKSSpec_AKSInstanceGroup{} }
func (m *CreateClusterAKSSpec_AKSInstanceGroup) String() string { return proto.CompactTextString(m) }
func (*CreateClusterAKSSpec_AKSInstanceGroup) ProtoMessage()    {}
func (*CreateClusterAKSSpec_AKSInstanceGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{13, 0}
}
func (m *CreateClusterAKSSpec_AKSInstanceGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup.Unmarshal(m, b)
}
func (m *CreateClusterAKSSpec_AKSInstanceGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup.Marshal(b, m, deterministic)
}
func (dst *CreateClusterAKSSpec_AKSInstanceGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup.Merge(dst, src)
}
func (m *CreateClusterAKSSpec_AKSInstanceGroup) XXX_Size() int {
	return xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup.Size(m)
}
func (m *CreateClusterAKSSpec_AKSInstanceGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterAKSSpec_AKSInstanceGroup proto.InternalMessageInfo

func (m *CreateClusterAKSSpec_AKSInstanceGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateClusterAKSSpec_AKSInstanceGroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CreateClusterAKSSpec_AKSInstanceGroup) GetMinQuantity() int32 {
	if m != nil {
		return m.MinQuantity
	}
	return 0
}

func (m *CreateClusterAKSSpec_AKSInstanceGroup) GetMaxQuantity() int32 {
	if m != nil {
		return m.MaxQuantity
	}
	return 0
}

// Tags are name/value pairs that enable you to categorize resources and view consolidated billing
type CreateClusterAKSSpec_Tags struct {
	// Tag key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Tag value
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateClusterAKSSpec_Tags) Reset()         { *m = CreateClusterAKSSpec_Tags{} }
func (m *CreateClusterAKSSpec_Tags) String() string { return proto.CompactTextString(m) }
func (*CreateClusterAKSSpec_Tags) ProtoMessage()    {}
func (*CreateClusterAKSSpec_Tags) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{13, 1}
}
func (m *CreateClusterAKSSpec_Tags) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateClusterAKSSpec_Tags.Unmarshal(m, b)
}
func (m *CreateClusterAKSSpec_Tags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateClusterAKSSpec_Tags.Marshal(b, m, deterministic)
}
func (dst *CreateClusterAKSSpec_Tags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateClusterAKSSpec_Tags.Merge(dst, src)
}
func (m *CreateClusterAKSSpec_Tags) XXX_Size() int {
	return xxx_messageInfo_CreateClusterAKSSpec_Tags.Size(m)
}
func (m *CreateClusterAKSSpec_Tags) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateClusterAKSSpec_Tags.DiscardUnknown(m)
}

var xxx_messageInfo_CreateClusterAKSSpec_Tags proto.InternalMessageInfo

func (m *CreateClusterAKSSpec_Tags) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CreateClusterAKSSpec_Tags) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Get version of API Server
type GetVersionMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVersionMsg) Reset()         { *m = GetVersionMsg{} }
func (m *GetVersionMsg) String() string { return proto.CompactTextString(m) }
func (*GetVersionMsg) ProtoMessage()    {}
func (*GetVersionMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{14}
}
func (m *GetVersionMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVersionMsg.Unmarshal(m, b)
}
func (m *GetVersionMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVersionMsg.Marshal(b, m, deterministic)
}
func (dst *GetVersionMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionMsg.Merge(dst, src)
}
func (m *GetVersionMsg) XXX_Size() int {
	return xxx_messageInfo_GetVersionMsg.Size(m)
}
func (m *GetVersionMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionMsg proto.InternalMessageInfo

// Reply for version request
type GetVersionReply struct {
	// If operation was OK
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// Version Information
	VersionInformation   *GetVersionReply_VersionInformation `protobuf:"bytes,2,opt,name=version_information,json=versionInformation,proto3" json:"version_information,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *GetVersionReply) Reset()         { *m = GetVersionReply{} }
func (m *GetVersionReply) String() string { return proto.CompactTextString(m) }
func (*GetVersionReply) ProtoMessage()    {}
func (*GetVersionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{15}
}
func (m *GetVersionReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVersionReply.Unmarshal(m, b)
}
func (m *GetVersionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVersionReply.Marshal(b, m, deterministic)
}
func (dst *GetVersionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionReply.Merge(dst, src)
}
func (m *GetVersionReply) XXX_Size() int {
	return xxx_messageInfo_GetVersionReply.Size(m)
}
func (m *GetVersionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionReply proto.InternalMessageInfo

func (m *GetVersionReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetVersionReply) GetVersionInformation() *GetVersionReply_VersionInformation {
	if m != nil {
		return m.VersionInformation
	}
	return nil
}

type GetVersionReply_VersionInformation struct {
	// The tag on the git repository
	GitVersion string `protobuf:"bytes,1,opt,name=git_version,json=gitVersion,proto3" json:"git_version,omitempty"`
	// The hash of the git commit
	GitCommit string `protobuf:"bytes,2,opt,name=git_commit,json=gitCommit,proto3" json:"git_commit,omitempty"`
	// Whether or not the tree was clean when built
	GitTreeState string `protobuf:"bytes,3,opt,name=git_tree_state,json=gitTreeState,proto3" json:"git_tree_state,omitempty"`
	// Date of build
	BuildDate string `protobuf:"bytes,4,opt,name=build_date,json=buildDate,proto3" json:"build_date,omitempty"`
	// Version of go used to compile
	GoVersion string `protobuf:"bytes,5,opt,name=go_version,json=goVersion,proto3" json:"go_version,omitempty"`
	// Compiler used
	Compiler string `protobuf:"bytes,6,opt,name=compiler,proto3" json:"compiler,omitempty"`
	// Platform it was compiled for / running on
	Platform             string   `protobuf:"bytes,7,opt,name=platform,proto3" json:"platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVersionReply_VersionInformation) Reset()         { *m = GetVersionReply_VersionInformation{} }
func (m *GetVersionReply_VersionInformation) String() string { return proto.CompactTextString(m) }
func (*GetVersionReply_VersionInformation) ProtoMessage()    {}
func (*GetVersionReply_VersionInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_fe88fb5975a7fb59, []int{15, 0}
}
func (m *GetVersionReply_VersionInformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVersionReply_VersionInformation.Unmarshal(m, b)
}
func (m *GetVersionReply_VersionInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVersionReply_VersionInformation.Marshal(b, m, deterministic)
}
func (dst *GetVersionReply_VersionInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionReply_VersionInformation.Merge(dst, src)
}
func (m *GetVersionReply_VersionInformation) XXX_Size() int {
	return xxx_messageInfo_GetVersionReply_VersionInformation.Size(m)
}
func (m *GetVersionReply_VersionInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionReply_VersionInformation.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionReply_VersionInformation proto.InternalMessageInfo

func (m *GetVersionReply_VersionInformation) GetGitVersion() string {
	if m != nil {
		return m.GitVersion
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGitCommit() string {
	if m != nil {
		return m.GitCommit
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGitTreeState() string {
	if m != nil {
		return m.GitTreeState
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGoVersion() string {
	if m != nil {
		return m.GoVersion
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetCompiler() string {
	if m != nil {
		return m.Compiler
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateClusterMsg)(nil), "cmaaks.CreateClusterMsg")
	proto.RegisterType((*CreateClusterReply)(nil), "cmaaks.CreateClusterReply")
	proto.RegisterType((*GetClusterMsg)(nil), "cmaaks.GetClusterMsg")
	proto.RegisterType((*GetClusterReply)(nil), "cmaaks.GetClusterReply")
	proto.RegisterType((*DeleteClusterMsg)(nil), "cmaaks.DeleteClusterMsg")
	proto.RegisterType((*DeleteClusterReply)(nil), "cmaaks.DeleteClusterReply")
	proto.RegisterType((*GetClusterListMsg)(nil), "cmaaks.GetClusterListMsg")
	proto.RegisterType((*GetClusterListReply)(nil), "cmaaks.GetClusterListReply")
	proto.RegisterType((*ClusterItem)(nil), "cmaaks.ClusterItem")
	proto.RegisterType((*ClusterDetailItem)(nil), "cmaaks.ClusterDetailItem")
	proto.RegisterType((*CreateClusterProviderSpec)(nil), "cmaaks.CreateClusterProviderSpec")
	proto.RegisterType((*AzureCredentials)(nil), "cmaaks.AzureCredentials")
	proto.RegisterType((*AzureClusterServiceAccount)(nil), "cmaaks.AzureClusterServiceAccount")
	proto.RegisterType((*CreateClusterAKSSpec)(nil), "cmaaks.CreateClusterAKSSpec")
	proto.RegisterType((*CreateClusterAKSSpec_AKSInstanceGroup)(nil), "cmaaks.CreateClusterAKSSpec.AKSInstanceGroup")
	proto.RegisterType((*CreateClusterAKSSpec_Tags)(nil), "cmaaks.CreateClusterAKSSpec.Tags")
	proto.RegisterType((*GetVersionMsg)(nil), "cmaaks.GetVersionMsg")
	proto.RegisterType((*GetVersionReply)(nil), "cmaaks.GetVersionReply")
	proto.RegisterType((*GetVersionReply_VersionInformation)(nil), "cmaaks.GetVersionReply.VersionInformation")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterClient interface {
	// Will provision a cluster
	CreateCluster(ctx context.Context, in *CreateClusterMsg, opts ...grpc.CallOption) (*CreateClusterReply, error)
	// Will retrieve the status of a cluster and its kubeconfig for connectivity
	GetCluster(ctx context.Context, in *GetClusterMsg, opts ...grpc.CallOption) (*GetClusterReply, error)
	// Will delete a cluster
	DeleteCluster(ctx context.Context, in *DeleteClusterMsg, opts ...grpc.CallOption) (*DeleteClusterReply, error)
	// Will retrieve a list of clusters
	GetClusterList(ctx context.Context, in *GetClusterListMsg, opts ...grpc.CallOption) (*GetClusterListReply, error)
	// Will return version information about api server
	GetVersionInformation(ctx context.Context, in *GetVersionMsg, opts ...grpc.CallOption) (*GetVersionReply, error)
}

type clusterClient struct {
	cc *grpc.ClientConn
}

func NewClusterClient(cc *grpc.ClientConn) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) CreateCluster(ctx context.Context, in *CreateClusterMsg, opts ...grpc.CallOption) (*CreateClusterReply, error) {
	out := new(CreateClusterReply)
	err := c.cc.Invoke(ctx, "/cmaaks.Cluster/CreateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetCluster(ctx context.Context, in *GetClusterMsg, opts ...grpc.CallOption) (*GetClusterReply, error) {
	out := new(GetClusterReply)
	err := c.cc.Invoke(ctx, "/cmaaks.Cluster/GetCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) DeleteCluster(ctx context.Context, in *DeleteClusterMsg, opts ...grpc.CallOption) (*DeleteClusterReply, error) {
	out := new(DeleteClusterReply)
	err := c.cc.Invoke(ctx, "/cmaaks.Cluster/DeleteCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetClusterList(ctx context.Context, in *GetClusterListMsg, opts ...grpc.CallOption) (*GetClusterListReply, error) {
	out := new(GetClusterListReply)
	err := c.cc.Invoke(ctx, "/cmaaks.Cluster/GetClusterList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetVersionInformation(ctx context.Context, in *GetVersionMsg, opts ...grpc.CallOption) (*GetVersionReply, error) {
	out := new(GetVersionReply)
	err := c.cc.Invoke(ctx, "/cmaaks.Cluster/GetVersionInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServer is the server API for Cluster service.
type ClusterServer interface {
	// Will provision a cluster
	CreateCluster(context.Context, *CreateClusterMsg) (*CreateClusterReply, error)
	// Will retrieve the status of a cluster and its kubeconfig for connectivity
	GetCluster(context.Context, *GetClusterMsg) (*GetClusterReply, error)
	// Will delete a cluster
	DeleteCluster(context.Context, *DeleteClusterMsg) (*DeleteClusterReply, error)
	// Will retrieve a list of clusters
	GetClusterList(context.Context, *GetClusterListMsg) (*GetClusterListReply, error)
	// Will return version information about api server
	GetVersionInformation(context.Context, *GetVersionMsg) (*GetVersionReply, error)
}

func RegisterClusterServer(s *grpc.Server, srv ClusterServer) {
	s.RegisterService(&_Cluster_serviceDesc, srv)
}

func _Cluster_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmaaks.Cluster/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).CreateCluster(ctx, req.(*CreateClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmaaks.Cluster/GetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetCluster(ctx, req.(*GetClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmaaks.Cluster/DeleteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).DeleteCluster(ctx, req.(*DeleteClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetClusterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterListMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetClusterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmaaks.Cluster/GetClusterList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetClusterList(ctx, req.(*GetClusterListMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetVersionInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetVersionInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmaaks.Cluster/GetVersionInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetVersionInformation(ctx, req.(*GetVersionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Cluster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cmaaks.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _Cluster_CreateCluster_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _Cluster_GetCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _Cluster_DeleteCluster_Handler,
		},
		{
			MethodName: "GetClusterList",
			Handler:    _Cluster_GetClusterList_Handler,
		},
		{
			MethodName: "GetVersionInformation",
			Handler:    _Cluster_GetVersionInformation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_api_fe88fb5975a7fb59) }

var fileDescriptor_api_fe88fb5975a7fb59 = []byte{
	// 1201 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4f, 0x8f, 0xdb, 0xc4,
	0x1b, 0x56, 0xb2, 0xc9, 0x36, 0x79, 0xd3, 0x4d, 0xb2, 0xd3, 0xdd, 0x36, 0x75, 0xfb, 0xeb, 0x2f,
	0x35, 0xa0, 0x96, 0x85, 0x24, 0x6d, 0x2a, 0xa4, 0x6a, 0x05, 0x12, 0x61, 0x2b, 0x4a, 0x28, 0x81,
	0xe2, 0x94, 0xbd, 0x20, 0x35, 0x4c, 0x9c, 0x59, 0xef, 0x10, 0x7b, 0xc6, 0x78, 0xc6, 0x69, 0xb7,
	0x27, 0xc4, 0x81, 0x0f, 0x00, 0x1f, 0x8d, 0x0b, 0x1f, 0x80, 0x2b, 0x12, 0xdc, 0x38, 0xf4, 0x80,
	0x66, 0x3c, 0xce, 0x5f, 0xb7, 0x45, 0xda, 0x93, 0xfd, 0xfe, 0x99, 0xe7, 0x7d, 0xe6, 0xf5, 0xf3,
	0xce, 0x18, 0xca, 0x38, 0xa4, 0xed, 0x30, 0xe2, 0x92, 0xa3, 0x6d, 0x37, 0xc0, 0x78, 0x2a, 0xac,
	0xeb, 0x1e, 0xe7, 0x9e, 0x4f, 0x3a, 0x38, 0xa4, 0x1d, 0xcc, 0x18, 0x97, 0x58, 0x52, 0xce, 0x44,
	0x92, 0x65, 0xbd, 0xaf, 0x1f, 0x6e, 0xcb, 0x23, 0xac, 0x25, 0x9e, 0x61, 0xcf, 0x23, 0x51, 0x87,
	0x87, 0x3a, 0x63, 0x33, 0xdb, 0x26, 0x50, 0x3f, 0x8a, 0x08, 0x96, 0xe4, 0xc8, 0x8f, 0x85, 0x24,
	0xd1, 0x40, 0x78, 0x08, 0x41, 0x81, 0xe1, 0x80, 0x34, 0x72, 0xcd, 0xdc, 0xed, 0xb2, 0xa3, 0xdf,
	0xd1, 0x47, 0x50, 0x0a, 0x23, 0x3e, 0xa3, 0x13, 0x12, 0x35, 0xf2, 0xcd, 0xdc, 0xed, 0x4a, 0xf7,
	0x66, 0x3b, 0xa1, 0xd3, 0x5e, 0x59, 0xff, 0xd8, 0x24, 0x0d, 0x43, 0xe2, 0x3a, 0xf3, 0x25, 0xf6,
	0x10, 0xd0, 0x4a, 0x9a, 0x43, 0x42, 0xff, 0x0c, 0x55, 0x21, 0xcf, 0xa7, 0xba, 0x4c, 0xc9, 0xc9,
	0xf3, 0x29, 0x6a, 0xc1, 0x05, 0x37, 0x89, 0x9b, 0x1a, 0x97, 0xe6, 0x35, 0x12, 0x77, 0x5f, 0x92,
	0xc0, 0x49, 0x73, 0xec, 0x11, 0xec, 0x3c, 0x24, 0xf2, 0x0d, 0xc4, 0x0f, 0xa1, 0xe2, 0x46, 0x64,
	0x42, 0x98, 0xa4, 0xd8, 0x17, 0x06, 0xb7, 0x91, 0xe2, 0xf6, 0x5e, 0xc4, 0x11, 0x39, 0x5a, 0xc4,
	0x9d, 0xe5, 0x64, 0xfb, 0x18, 0x6a, 0x8b, 0x02, 0xd9, 0x94, 0xef, 0xad, 0x53, 0xbe, 0xba, 0x46,
	0xf9, 0x01, 0x91, 0x98, 0xfa, 0xab, 0xc4, 0xc7, 0x50, 0x7f, 0x40, 0x7c, 0xf2, 0xc6, 0xa6, 0x9f,
	0x87, 0xfb, 0x87, 0x80, 0x56, 0x6a, 0x64, 0xd3, 0xbf, 0x0c, 0xdb, 0x42, 0x62, 0x19, 0x27, 0xe0,
	0x65, 0xc7, 0x58, 0xf6, 0x57, 0xb0, 0xbb, 0xd8, 0xf9, 0x17, 0x54, 0x48, 0x45, 0xf1, 0x7c, 0xad,
	0xbc, 0xb4, 0x0a, 0x98, 0xcd, 0xa7, 0x03, 0x25, 0xd3, 0x24, 0x85, 0xbf, 0xf5, 0x2a, 0x09, 0xcc,
	0x93, 0xec, 0x3e, 0x54, 0x96, 0x02, 0x0a, 0x8f, 0x4e, 0x4c, 0x0f, 0xf3, 0x74, 0x32, 0xef, 0x6a,
	0x7e, 0xa9, 0xab, 0x8b, 0x3d, 0x6f, 0xad, 0xec, 0x99, 0xc3, 0xee, 0xc6, 0x37, 0x3b, 0x0f, 0x20,
	0xba, 0x01, 0x30, 0x8d, 0xc7, 0xc4, 0xe5, 0xec, 0x84, 0x7a, 0x8d, 0x82, 0x8e, 0x2d, 0x79, 0xec,
	0xdf, 0x73, 0x70, 0xf5, 0x95, 0xc3, 0x93, 0x29, 0x88, 0xff, 0x43, 0x65, 0x7a, 0x5f, 0x8c, 0x66,
	0x24, 0x12, 0x94, 0x33, 0x43, 0x02, 0xa6, 0xf7, 0xc5, 0x71, 0xe2, 0x41, 0x5d, 0x28, 0x62, 0xf5,
	0x1d, 0x34, 0x93, 0x4a, 0xf7, 0x7a, 0xe6, 0x8c, 0xf6, 0x1e, 0x0d, 0xf5, 0x78, 0x26, 0xa9, 0xe8,
	0x3d, 0xd8, 0x3d, 0xa5, 0xde, 0xe9, 0x08, 0xcf, 0x30, 0xf5, 0xf1, 0x98, 0xfa, 0x54, 0x9e, 0x69,
	0xb6, 0x25, 0xa7, 0xae, 0x02, 0xbd, 0x25, 0x3f, 0x7a, 0x07, 0xaa, 0x8c, 0xc8, 0x67, 0x3c, 0x9a,
	0x8e, 0x4e, 0xf0, 0x38, 0xa2, 0x6e, 0xa3, 0xa8, 0x49, 0xec, 0x18, 0xef, 0xa7, 0xda, 0x69, 0xff,
	0x9c, 0x83, 0xfa, 0xba, 0x20, 0xd0, 0x3e, 0x6c, 0xe3, 0x30, 0x1c, 0xcd, 0xfb, 0x59, 0xc4, 0x61,
	0xd8, 0x9f, 0xa8, 0xf6, 0x49, 0xc2, 0x30, 0x93, 0xa9, 0x06, 0x13, 0x0b, 0x59, 0x50, 0x0a, 0xb1,
	0x10, 0xcf, 0x78, 0x34, 0x31, 0x8d, 0x9d, 0xdb, 0xe8, 0x16, 0xd4, 0x44, 0x3c, 0x16, 0x6e, 0x44,
	0xf5, 0xc9, 0xa6, 0x30, 0x93, 0xfe, 0x56, 0x97, 0xdd, 0xfd, 0x89, 0xfd, 0x14, 0xac, 0x84, 0x47,
	0xb2, 0xf5, 0x21, 0x89, 0x66, 0xd4, 0x25, 0x3d, 0xd7, 0xe5, 0x31, 0x93, 0xe8, 0x1a, 0x94, 0x5d,
	0x9f, 0x12, 0x26, 0x17, 0xa4, 0x4a, 0x89, 0xa3, 0x3f, 0x41, 0x6f, 0xc1, 0x8e, 0x09, 0x0a, 0xe2,
	0x46, 0x24, 0xa5, 0x77, 0x31, 0x71, 0x0e, 0xb5, 0xcf, 0x7e, 0xb9, 0x05, 0x7b, 0x59, 0xcd, 0x55,
	0xec, 0x7d, 0xee, 0xea, 0xb3, 0x36, 0x45, 0x4e, 0xed, 0xf3, 0x0c, 0x12, 0xfa, 0x1c, 0xaa, 0x46,
	0xfc, 0x66, 0x13, 0xe6, 0x53, 0xdb, 0xab, 0xcb, 0xb3, 0xb6, 0xeb, 0xac, 0xad, 0x44, 0xc7, 0x50,
	0xa3, 0x4c, 0x48, 0xcc, 0x5c, 0x32, 0xf2, 0x22, 0x1e, 0x87, 0xa2, 0x51, 0xd0, 0x43, 0xd7, 0x7a,
	0x9d, 0x6e, 0xda, 0xbd, 0x47, 0xc3, 0xbe, 0x59, 0xf6, 0x50, 0xad, 0x72, 0xaa, 0x74, 0xd9, 0x14,
	0xe8, 0x03, 0x28, 0x48, 0xec, 0x89, 0x46, 0x51, 0x83, 0xdd, 0x7c, 0x2d, 0xd8, 0x13, 0xec, 0x09,
	0x47, 0xa7, 0x5b, 0x3f, 0x2a, 0xd1, 0xac, 0x61, 0x67, 0x8e, 0x01, 0x82, 0x82, 0x3c, 0x0b, 0xe7,
	0x43, 0xa8, 0xde, 0xd1, 0x4d, 0xb8, 0x18, 0x50, 0x36, 0xfa, 0x21, 0xc6, 0x4c, 0x2a, 0x01, 0xab,
	0xae, 0x14, 0x9d, 0x4a, 0x40, 0xd9, 0xd7, 0xc6, 0xa5, 0x53, 0xf0, 0xf3, 0x45, 0x4a, 0xc1, 0xa4,
	0xe0, 0xe7, 0x69, 0x8a, 0xd5, 0x86, 0x82, 0x22, 0x84, 0xea, 0xb0, 0x35, 0x25, 0x67, 0xa6, 0xa8,
	0x7a, 0x45, 0x7b, 0x50, 0x9c, 0x61, 0x3f, 0x4e, 0x8b, 0x26, 0x86, 0x5d, 0xd3, 0x57, 0x90, 0x99,
	0xbe, 0x81, 0xf0, 0xec, 0xbf, 0xf3, 0xfa, 0xce, 0x30, 0x9e, 0xec, 0x43, 0xee, 0x5b, 0xb8, 0x64,
	0x26, 0x78, 0x44, 0xd9, 0x09, 0x8f, 0x82, 0x44, 0x25, 0x89, 0x0c, 0x0e, 0xd2, 0x6e, 0xad, 0xa1,
	0xb4, 0x8d, 0xd1, 0x5f, 0xac, 0x70, 0xd0, 0x6c, 0xc3, 0x67, 0xfd, 0x95, 0x03, 0xb4, 0x99, 0xaa,
	0x4e, 0x0e, 0x8f, 0xca, 0xf9, 0xc9, 0x91, 0x6c, 0x0c, 0x3c, 0x9a, 0xd6, 0x40, 0xff, 0x03, 0x65,
	0x8d, 0x5c, 0x1e, 0x04, 0x34, 0x95, 0x7a, 0xd9, 0xa3, 0xf2, 0x48, 0x3b, 0xd0, 0xdb, 0x50, 0x55,
	0x61, 0x19, 0x11, 0x32, 0x52, 0xc7, 0x1b, 0x31, 0x23, 0x79, 0xd1, 0xa3, 0xf2, 0x49, 0x44, 0xc8,
	0x50, 0xf9, 0x14, 0xc8, 0x38, 0xa6, 0xfe, 0x64, 0x34, 0x51, 0x19, 0xc9, 0x44, 0x96, 0xb5, 0xe7,
	0x81, 0x09, 0x7b, 0x7c, 0xce, 0xa1, 0x68, 0x6a, 0xf0, 0x94, 0x82, 0x05, 0x25, 0x97, 0x07, 0x21,
	0xf5, 0x49, 0xd4, 0xd8, 0x36, 0xc3, 0x68, 0x6c, 0x7d, 0x18, 0xf8, 0x58, 0xaa, 0x0d, 0x35, 0x2e,
	0x98, 0xc3, 0xc0, 0xd8, 0xdd, 0x3f, 0xb7, 0xe0, 0x82, 0x51, 0x15, 0xc2, 0xb0, 0xb3, 0x22, 0x33,
	0xd4, 0xc8, 0x54, 0xdf, 0x40, 0x78, 0x96, 0x95, 0x19, 0xd1, 0xcd, 0xb6, 0xad, 0x9f, 0x7e, 0xfb,
	0xe3, 0xd7, 0xfc, 0x9e, 0x55, 0xd3, 0x3f, 0x59, 0xb3, 0xbb, 0x1d, 0x33, 0x39, 0x87, 0xb9, 0x03,
	0xf4, 0x0d, 0xc0, 0xe2, 0x2a, 0x43, 0xfb, 0x4b, 0xdf, 0x6b, 0x09, 0xfc, 0xca, 0xa6, 0x3b, 0x41,
	0xbe, 0xa2, 0x91, 0x77, 0xd1, 0x3a, 0x32, 0x7a, 0x0a, 0x3b, 0x2b, 0x17, 0xf6, 0x82, 0xf9, 0xfa,
	0xbf, 0xc2, 0x82, 0xf9, 0xe6, 0x0d, 0x9f, 0xe2, 0x1f, 0x6c, 0xe0, 0x9f, 0x40, 0x75, 0xf5, 0x06,
	0x46, 0x57, 0x37, 0x39, 0x9a, 0xab, 0xde, 0xba, 0x96, 0x1d, 0x4a, 0x4a, 0x5c, 0xd7, 0x25, 0x2e,
	0xa3, 0xbd, 0xb5, 0x12, 0x1d, 0x5f, 0xa1, 0x7e, 0x07, 0xfb, 0x0b, 0xe9, 0x2e, 0x4b, 0x70, 0x7f,
	0x53, 0xd9, 0xeb, 0x9d, 0x5a, 0x16, 0xfc, 0x66, 0xa7, 0x8c, 0x70, 0x3e, 0x79, 0x99, 0xfb, 0xa5,
	0xf7, 0x4f, 0x0e, 0x3d, 0x87, 0x1b, 0x86, 0x5a, 0x73, 0x80, 0x19, 0xf6, 0x48, 0xd4, 0xec, 0x3d,
	0x1a, 0x36, 0x3f, 0x23, 0x7e, 0xa8, 0x5e, 0x1f, 0xf7, 0xed, 0x2f, 0xa1, 0x36, 0xa0, 0xee, 0x29,
	0x26, 0x7e, 0xf3, 0x98, 0x30, 0xf2, 0x82, 0x62, 0x74, 0xeb, 0x54, 0xca, 0x50, 0x1c, 0x76, 0x3a,
	0x1e, 0x95, 0xa7, 0xf1, 0xb8, 0xed, 0xf2, 0xa0, 0x23, 0x70, 0x20, 0x62, 0xe6, 0xb5, 0x5c, 0xe6,
	0xca, 0x8e, 0x1b, 0xe0, 0x96, 0xfa, 0xc9, 0x46, 0xc1, 0x2c, 0x59, 0xf2, 0xb1, 0x17, 0x60, 0xea,
	0xab, 0xc4, 0xee, 0xf6, 0xec, 0x4e, 0xfb, 0x6e, 0xfb, 0xce, 0x41, 0x3e, 0x9f, 0xeb, 0xd6, 0x71,
	0x18, 0xfa, 0x34, 0x39, 0xd0, 0x3b, 0xdf, 0x0b, 0xce, 0x0e, 0x37, 0x3c, 0xd1, 0x13, 0x78, 0x77,
	0xc0, 0x23, 0xd2, 0xc4, 0x63, 0x1e, 0xcb, 0xe6, 0xeb, 0xc9, 0xfe, 0x67, 0x66, 0xe3, 0x6d, 0xfd,
	0xe7, 0x7e, 0xef, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x2e, 0xbc, 0x1c, 0x1a, 0x0c, 0x00,
	0x00,
}
